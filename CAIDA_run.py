"""
Run ACF data structure on CAIDA traces

Example 1 (without sampling): python CAIDA_run.py -input_trae trace.dat --no-sample
Example 2 (with sampling): python CAIDA_run.py -input_trae trace.dat --sample -sample_rate 0.1
"""

import argparse
import pickle
import threading
import matplotlib.pyplot as plt
from tqdm import tqdm

from util import *
from acf_firewall import ACF


def run_thread(tid, fiveTuple_list, ratio, n_flows, ACF_c, res_map, res_map_lock):
    """
    Calculate false positive rate of ACF
    parameters:
        tid: thread id
        fiveTuple_list: packet trace
        ratio: A/S ratio
        n_flows: #number of flows in packet trace
        ACF_c: number of cells per bucket in ACF
        res_map: mapping between A/S ratio and FP rate
        res_map_lock: lock associated with mapping
    """
    print("[Thread {}] ratio={} started".format(tid, ratio))
    fp_rate = 0.0
    FP = 0
    TN = 0

    # First, let's calculate the number of flows 
    # for set A and set S
    S_flows = int(n_flows / (1 + ratio))
    A_flows = n_flows - S_flows

    # Based on ACF paper, ACF reaches the 
    # 95% load when it is filled
    acf = ACF(b=int(S_flows / 0.95), c=ACF_c)
    st = set()
    A_st = set()
    for fiveTuple in tqdm(fiveTuple_list, desc="[Thread {}]".format(tid)):
        # TODO: It seems hash_with_offset requires input to be integer
        # So we convert the fiveTuple back
        fiveTuple = int.from_bytes(fiveTuple, byteorder="little")
        if len(st) <= S_flows:
            if fiveTuple not in st:
                acf.insert(fiveTuple)
                st.add(fiveTuple)
        else:
            # The remaining are used to 
            # check false positive rate 
            if acf.check_membership(fiveTuple):
                if fiveTuple not in st:
                    FP += 1
                    # Now adaptive
                    acf.adapt_false_positive(fiveTuple)
            else:
                if fiveTuple not in st:
                    TN += 1
    fp_rate = FP / (FP + TN)
    with res_map_lock:
        res_map[ratio] = fp_rate
    print("[Thread {}] ratio={} finished".format(tid, ratio))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run ACF data structure on CAIDA traces")
    parser.add_argument('-input_trace', type=str, help="input CAIDA trace file")
    add_bool_arg(parser, "sample")
    parser.add_argument('-sample_rate', type=float, default=0.1, help="the sample rate")
    args = parser.parse_args()

    # Load trace (generated by CAIDA/preprocess.py)
    fiveTuple_list = load_trace(args.input_trace, args.sample, args.sample_rate)
    # Get stats of this trace
    n_flows, n_pkts = get_trace_stats(fiveTuple_list)

    # A/S ratio (Michael's sec4.2 experiment)
    ratio_list = [i for i in range(1, 6)] + [i * 10 for i in range(1, 11)]

    fig, ax = plt.subplots()
    C_list = [1, 4]
    marker_style_list = ["o", "v"]
    for marker_style, ACF_c in zip(marker_style_list, C_list):
        res_map_lock = threading.Lock()
        res_map = dict()
        # Parallel between different ratio
        thread_list = [threading.Thread(target=run_thread, 
                       args=(tid, fiveTuple_list, ratio, n_flows, ACF_c, res_map, res_map_lock)) \
                       for tid, ratio in enumerate(ratio_list)]
        for thread in thread_list:
            thread.start()
        for thread in thread_list:
            thread.join()

        fp_list = []
        for ratio in ratio_list:
            fp_list.append(res_map[ratio])
        ax.plot(ratio_list, fp_list, "-{}".format(marker_style), fillstyle="none", label="ACF (c={})".format(ACF_c))

    ax.set_xlabel("A/S ratio")
    ax.set_ylabel("False positive rate")
    ax.set_yscale('log')
    ax.legend()
    fig.savefig("res.png")


    